<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>Document</title>
    <link
      rel="stylesheet"
      href="./@capsule/global.css"
    />
    <script src="./@capsule/utils/ripple.js"></script>
    <script
      type="module"
      src="./@capsule/components/init.js"
    ></script>
  </head>
  <body>
    <capsule-button variant="primary"> —Ç–µ—Å—Ç </capsule-button>

    <capsule-skeleton variant="rectangular"></capsule-skeleton>
    <form id="form">
      <capsule-slider
        show-ticks
        step="10"
        name="test"
      >
      </capsule-slider>

      <capsule-switch name="kek"></capsule-switch>

      <capsule-badge
        value="1000"
        max="+99"
      >
        <span>–°–æ–æ–±—â–µ–Ω–∏—è</span>
      </capsule-badge>

      <capsule-chip>Default Chip</capsule-chip>
      <capsule-chip variant="outline">Outline Chip</capsule-chip>
      <capsule-chip variant="ghost">Ghost Chip</capsule-chip>
      <capsule-chip color="success">Success Chip</capsule-chip>
      <capsule-chip
        size="lg"
        variant=""
        color="error"
      >
        Error Outline
      </capsule-chip>
      <capsule-chip size="sm">Small Chip</capsule-chip>

      <capsule-pagination
        total-pages="20"
        show-boundary-pages
        items-per-page="7"
        visible-pages="3"
        onchange="console.log(event)"
      >
        <span slot="ellipsis">...</span>

        <capsule-button slot="first">¬´</capsule-button>
        <capsule-button slot="previous">‚Äπ</capsule-button>

        <capsule-button slot="next">‚Ä∫</capsule-button>
        <capsule-button slot="last">¬ª</capsule-button>
      </capsule-pagination>

      <capsule-accordion>
        <capsule-accordion-item open>
          <div slot="trigger">–ü–µ—Ä–≤–∞—è —Å–µ–∫—Ü–∏—è</div>
          <div slot="content">
            <p>–ö–æ–Ω—Ç–µ–Ω—Ç —Å –∫—Ä–∞—Å–∏–≤–æ–π –∞–Ω–∏–º–∞—Ü–∏–µ–π –ø–æ—è–≤–ª–µ–Ω–∏—è</p>
          </div>
        </capsule-accordion-item>

        <capsule-accordion-item>
          <div slot="trigger">Popout –≤–∞—Ä–∏–∞–Ω—Ç</div>
          <div slot="content">–í—ã–¥–≤–∏–≥–∞–µ—Ç—Å—è –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏</div>
        </capsule-accordion-item>
      </capsule-accordion>

      <capsule-divider></capsule-divider>
      <capsule-rating
        value="1.5"
        max="5"
        precision="0.1"
        color="primary"
        name="rating"
      >
        <span slot="star-1-empty">üò¥</span>
        <span slot="star-1-filled">üòç</span>
        <span slot="star-2-empty">üò¥</span>
        <span slot="star-2-filled">üòç</span>
      </capsule-rating>

      <capsule-button
        type="submit"
        transition='{"duration": 1000}'
      >
        Submit
      </capsule-button>
    </form>

    <motion-element
      initial='{"opacity": "0"}'
      animate='{"opacity": "1"}'
      transition='{"duration": 1000, "ease": "ease-out"}'
      style="width: 100px; height: 100px; background: #4ecdc4"
    >
      Fade In
    </motion-element>

    <motion-element
      initial='{"opacity": "0", "transform": "scale(0.5) rotate(45deg)"}'
      animate='{"opacity": "1", "transform": "scale(1) rotate(0deg)"}'
      transition='{"duration": 1000, "ease": "ease-out"}'
      style="width: 100px; height: 100px; background: #ff6b6b"
    >
      Scale + Rotate
    </motion-element>

    <motion-element
      initial='{"transform": "rotate(0deg)"}'
      animate='{"transform": "rotate(0deg)"}'
      while-hover='{"transform": "rotate(180deg)", "background": "green"}'
      style="width: 100px; height: 100px; background: #4ecdc4; cursor: pointer"
    >
      Hover Me!
    </motion-element>

    <script defer>
      form.onsubmit = (e) => {
        e.preventDefault();
        console.log(new FormData(e.currentTarget));
      };
    </script>

    <script>
      class MotionElement extends HTMLElement {
        static observedAttributes = [
          'animate',
          'initial',
          'while-hover',
          'while-tap',
          'transition',
        ];

        constructor() {
          super();
          this.attachShadow({ mode: 'open' });

          this._animations = new Map();
        }

        connectedCallback() {
          this._render();

          this._applyInitial();

          requestAnimationFrame(() => {
            this._applyAnimate();
          });

          this._attachEventListeners();
        }

        attributeChangedCallback(name, oldValue, newValue) {
          if (oldValue === newValue) return;

          switch (name) {
            case 'animate':
              this._applyAnimate();
              break;
            case 'initial':
              this._applyInitial();
              break;
          }
        }

        _render() {
          this.shadowRoot.innerHTML = `
            <style>
              :host {
                display: inline-flex;
              }
            </style>
            <slot></slot>
          `;
        }

        _applyInitial() {
          const initial = this.getAttribute('initial');
          if (!initial) return;

          try {
            const styles = JSON.parse(initial);

            Object.entries(styles).forEach(([property, value]) => {
              this.style.setProperty(property, value);
            });
          } catch (error) {
            console.error('Error parsing initial JSON:', error);
          }
        }

        _applyAnimate() {
          const animate = this.getAttribute('animate');
          if (!animate) return;

          try {
            const styles = JSON.parse(animate);
            const transition = this._parseTransition();

            this._animateWithWAAPI(styles, transition);
          } catch (error) {
            console.error('Error parsing animate JSON:', error);
          }
        }

        _parseTransition() {
          const transition = this.getAttribute('transition');
          if (!transition) return { duration: 300, ease: 'ease' };

          try {
            return JSON.parse(transition);
          } catch {
            return { duration: 300, ease: 'ease' };
          }
        }

        _animateWithWAAPI(styles, transition) {
          Object.keys(styles).forEach((property) => {
            this._animations.get(property)?.cancel();
          });

          const { duration = 300, ease = 'ease', delay = 0 } = transition;

          Object.entries(styles).forEach(([property, value]) => {
            const currentValue =
              this.style.getPropertyValue(property) ||
              getComputedStyle(this).getPropertyValue(property);

            const animation = this.animate(
              {
                [property]: [currentValue, value],
              },
              {
                duration,
                easing: ease,
                delay,
                fill: 'forwards',
              }
            );

            this._animations.set(property, animation);

            animation.onfinish = () => {
              this.style.setProperty(property, value);
              this._animations.delete(property);
            };
          });
        }

        _attachEventListeners() {
          this._setupHoverAnimation();
          this._setupTapAnimation();
        }

        _setupHoverAnimation() {
          const whileHover = this.getAttribute('while-hover');
          if (!whileHover) return;

          try {
            const hoverStyles = JSON.parse(whileHover);

            this.addEventListener('mouseenter', () => {
              this._animateWithWAAPI(hoverStyles, { duration: 200 });
            });

            this.addEventListener('mouseleave', () => {
              const animate = this.getAttribute('animate');
              if (animate) {
                const defaultStyles = JSON.parse(animate);
                this._animateWithWAAPI(defaultStyles, { duration: 200 });
              }
            });
          } catch (error) {
            console.error('Error parsing while-hover JSON:', error);
          }
        }

        _setupTapAnimation() {
          const whileTap = this.getAttribute('while-tap');
          if (!whileTap) return;

          try {
            const tapStyles = JSON.parse(whileTap);

            this.addEventListener('mousedown', () => {
              this._animateWithWAAPI(tapStyles, { duration: 100 });
            });

            this.addEventListener('mouseup', () => {
              const animate = this.getAttribute('animate');
              if (animate) {
                const defaultStyles = JSON.parse(animate);
                this._animateWithWAAPI(defaultStyles, { duration: 100 });
              }
            });

            this.addEventListener('touchstart', () => {
              this._animateWithWAAPI(tapStyles, { duration: 100 });
            });

            this.addEventListener('touchend', () => {
              const animate = this.getAttribute('animate');
              if (animate) {
                const defaultStyles = JSON.parse(animate);
                this._animateWithWAAPI(defaultStyles, { duration: 100 });
              }
            });
          } catch (error) {
            console.error('Error parsing while-tap JSON:', error);
          }
        }

        // Public API
        start(animation, options = {}) {
          try {
            const styles =
              typeof animation === 'string' ? JSON.parse(animation) : animation;
            this._animateWithWAAPI(styles, options);
          } catch (error) {
            console.error('Error parsing start animation:', error);
          }
        }

        stop() {
          this._animations.forEach((animation) => animation.cancel());
          this._animations.clear();
        }

        setVariants(variants) {
          this._variants = variants;
        }

        variant(name) {
          if (this._variants && this._variants[name]) {
            this.start(this._variants[name]);
          }
        }

        reset() {
          this.stop();
          this._applyInitial();
        }
      }

      customElements.define('motion-element', MotionElement);
    </script>
  </body>
</html>
