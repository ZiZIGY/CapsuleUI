<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>Document</title>
    <link
      rel="stylesheet"
      href="./@capsule/global.css"
    />
    <script src="./@capsule/utils/ripple.js"></script>
    <script
      type="module"
      src="./@capsule/components/init.js"
    ></script>
  </head>
  <body>
    <capsule-button variant="primary"> Ñ‚ĞµÑÑ‚ </capsule-button>

    <capsule-skeleton variant="rectangular"></capsule-skeleton>

    <form id="form">
      <form-field>
        <capsule-rating
          value="1.5"
          max="5"
          precision="0.1"
          color="primary"
          name="rating"
        >
          <span slot="star-1-empty">ğŸ˜´</span>
          <span slot="star-1-filled">ğŸ˜</span>
          <span slot="star-2-empty">ğŸ˜´</span>
          <span slot="star-2-filled">ğŸ˜</span>
        </capsule-rating>

        <form-message></form-message>
      </form-field>

      <capsule-button type="submit"> Submit </capsule-button>
    </form>

    <script defer>
      class CapsuleValidator {
        constructor(formSelector, options = {}) {
          this.form = document.querySelector(formSelector);
          this.fields = options.fields || {};
          this.options = {
            validateOnInput: options.validateOnInput || false,
            validateOnChange: options.validateOnChange || false,
            bails: options.bails !== false,
            initialValues: options.initialValues || {},

            formFieldSelector: options.formFieldSelector || 'form-field',
            formMessageSelector: options.formMessageSelector || 'form-message',
          };

          this.setValues(this.options.initialValues);

          this.form.addEventListener('input', (e) => {
            const field = e.target.closest(this.options.formFieldSelector);
            if (field) {
              const fieldName = this.getFieldName(field);
              this.clearError(fieldName);

              if (this.options.validateOnInput) {
                this.validateField(fieldName);
              }
            }
          });

          this.form.addEventListener('change', (e) => {
            const field = e.target.closest(this.options.formFieldSelector);
            if (field) {
              const fieldName = this.getFieldName(field);
              this.clearError(fieldName);

              if (this.options.validateOnChange) {
                this.validateField(fieldName);
              }
            }
          });
        }

        async validate() {
          const formData = new FormData(this.form);
          const allValues = Object.fromEntries(formData);
          const errors = {};

          for (const [fieldName, rules] of Object.entries(this.fields)) {
            const result = await this.validateField(fieldName, allValues);
            if (!result.valid) {
              errors[fieldName] = result.errors[0];
            }
          }

          return {
            valid: Object.keys(errors).length === 0,
            errors,
            values: allValues,
          };
        }

        async validateField(fieldName, allValues = null) {
          if (!allValues) {
            const formData = new FormData(this.form);
            allValues = Object.fromEntries(formData);
          }

          const value = allValues[fieldName];
          const rules = this.fields[fieldName] || [];
          const errors = [];

          for (const rule of rules) {
            try {
              const result = await rule(value, allValues);
              if (typeof result === 'string') {
                errors.push(result);
                if (this.options.bails) break;
              }
            } catch (error) {
              errors.push(error.message || 'ĞÑˆĞ¸Ğ±ĞºĞ° Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸');
              if (this.options.bails) break;
            }
          }

          return {
            valid: errors.length === 0,
            errors,
          };
        }

        static rules = {
          required:
            (message = 'ĞŸĞ¾Ğ»Ğµ Ğ¾Ğ±ÑĞ·Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ Ğ´Ğ»Ñ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ') =>
            (v) =>
              !!v || message,
          email:
            (message = 'Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğ¹ email') =>
            (v) =>
              !v || /^\S+@\S+\.\S+$/.test(v) || message,
          min: (length, message) => (v) =>
            !v || v.length >= length || message || `ĞœĞ¸Ğ½Ğ¸Ğ¼ÑƒĞ¼ ${length} ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²`,
          max: (length, message) => (v) =>
            !v ||
            v.length <= length ||
            message ||
            `ĞœĞ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ ${length} ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²`,
          minValue: (min, message) => (v) =>
            !v ||
            Number(v) >= min ||
            message ||
            `Ğ—Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ¾ Ğ±Ñ‹Ñ‚ÑŒ Ğ½Ğµ Ğ¼ĞµĞ½ĞµĞµ ${min}`,
          maxValue: (max, message) => (v) =>
            !v ||
            Number(v) <= max ||
            message ||
            `Ğ—Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ¾ Ğ±Ñ‹Ñ‚ÑŒ Ğ½Ğµ Ğ±Ğ¾Ğ»ĞµĞµ ${max}`,
          match: (fieldToMatch, message) => (v, allValues) =>
            !v ||
            v === allValues[fieldToMatch] ||
            message ||
            `ĞŸĞ¾Ğ»Ğµ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ¾ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´Ğ°Ñ‚ÑŒ Ñ ${fieldToMatch}`,
          async:
            (validator, message = 'ĞÑˆĞ¸Ğ±ĞºĞ° Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸') =>
            async (v, allValues) => {
              try {
                const isValid = await validator(v, allValues);
                return isValid || message;
              } catch (error) {
                return error.message || message;
              }
            },
        };

        getFieldName(fieldElement) {
          const field = fieldElement.querySelector('[name]');
          return field ? field.name : fieldElement.getAttribute('name');
        }

        displayErrors(errors) {
          this.form
            .querySelectorAll(this.options.formFieldSelector)
            .forEach((field) => {
              field.setError(null, this.options.formMessageSelector);
            });

          Object.keys(errors).forEach((fieldName) => {
            this.setFieldError(fieldName, errors[fieldName]);
          });
        }

        setFieldError(fieldName, error) {
          const field = this.findFieldByName(fieldName);
          if (field) {
            field.setError(error, this.options.formMessageSelector);
          }
        }

        findFieldByName(fieldName) {
          return (
            this.form
              .querySelector(`[name="${fieldName}"]`)
              ?.closest(this.options.formFieldSelector) ||
            this.form
              .querySelector(
                `${this.options.formFieldSelector} [name="${fieldName}"]`
              )
              ?.closest(this.options.formFieldSelector)
          );
        }

        clearError(fieldName) {
          const field = this.findFieldByName(fieldName);
          if (field) {
            field.setError(null, this.options.formMessageSelector);
          }
        }

        setValues(values) {
          Object.entries(values).forEach(([fieldName, value]) => {
            const input = this.form.querySelector(`[name="${fieldName}"]`);
            if (input) {
              input.value = value;
            }
          });
        }

        reset() {
          this.form.reset();
          this.form
            .querySelectorAll(this.options.formFieldSelector)
            .forEach((field) => {
              field.setError(null, this.options.formMessageSelector);
            });
          this.setValues(this.options.initialValues);
        }

        getFormData() {
          const formData = new FormData(this.form);
          return Object.fromEntries(formData);
        }
      }

      class FormField extends HTMLElement {
        constructor() {
          super();
        }

        setError(message) {
          const messageElement = this.querySelector('form-message');
          if (messageElement) {
            if (message) {
              messageElement.setMessage(message);
              this.classList.add('invalid');
            } else {
              messageElement.clearMessage();
              this.classList.remove('invalid');
            }
          }
        }
      }

      customElements.define('form-field', FormField);

      class FormMessage extends HTMLElement {
        constructor() {
          super();
        }

        connectedCallback() {
          this.style.display = 'none';
        }

        setMessage(message) {
          this.textContent = message;
          this.style.display = 'block';
        }

        clearMessage() {
          this.textContent = '';
          this.style.display = 'none';
        }
      }

      customElements.define('form-message', FormMessage);

      const standardValidator = new CapsuleValidator('#form', {
        fields: {
          rating: [
            CapsuleValidator.rules.required(),
            CapsuleValidator.rules.minValue(3),
          ],
        },
        validateOnInput: true,
        onSubmit: () => {},
        onError: () => {},
      });
    </script>
  </body>
</html>
